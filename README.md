# CipherAuthenticBreaker
The approach I took was very brute force. At the beginning, I just used each hashlib algorithm (sha1, sha225, sha384, md5, etc) and compared it with each password. Without any looping, the passwords for user1, user4, and user5 were revealed. Next, I implemented the caesar shift using a simple loop. It shifted the individual letter if was a number. I also had to account for edge cases. However, the tricky part was when I began to write the leet function. I was first translating from number to letter, but I read the directions a little wrong, so switched it. The leet function recurses through every possibility of every length. I didn't change it yet so that only words equal to the user password size are accepted into the leetlist or storage I made. This function takes a while to load the matching hash. A way to optimize this would be to target known words or common words, but for now, this works. I'm still working on my salt method, but before I go into that I want to talk about the .py in general. My password cracker hashlibs after every different encryption scheme. The nested just checks if any weren't encrypted using Caesar, Leet, or SALT, else, I check each case if the previous one failed. So I currently have 1hr 20 min to turn it the hw, I just finished getting the password for user7, but I spent too much time on trying to find salt. I'm not quite sure what I'm doing wrong. 1. For each dictionary.txt word, I add an arbitrary five digit sequence that are between 0 and 9. I recurse through all possible permutations and put it into a list. I loop through the list again and append the current dictionary.txt word (in hindsight I don't have to loop through again). After, getting the list of possible salt combinations for one word, I loop through and hash each one and check if that hashing is equivalent to the one given in shadow for user2. I know I'm sooo close, but I'm not sure what I did wrong.  
