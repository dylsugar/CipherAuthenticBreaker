The approach I took was very brute force. At the beginning, I just used each hashlib algorithm (sha1, sha225, sha384, md5, etc) and compared it with each password. Without any looping, the passwords for user1, user4, and user5 were revealed. Next, I implemented the caesar shift using a simple loop. It shifted the individual letter if was a number. I also had to account for edge cases. However, the tricky part was when I began to write the leet function. I was first translating from number to letter, but I read the directions a little wrong, so switched it. The leet function recurses through every possibility of every length. I didn't change it yet so that only words equal to the user password size are accepted into the leetlist or storage I made. This function takes a while to load the matching hash. A way to optimize this would be to target known words or common words, but for now, this works. I'm still working on my salt method, but before I go into that I want to talk about the .py in general. My password cracker hashlibs after every different encryption scheme. The nested just checks if any weren't encrypted using Caesar, Leet, or SALT, else, I check each case if the previous one failed. 
